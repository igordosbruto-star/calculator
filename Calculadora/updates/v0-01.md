# v0-01.md — Cortes & Persistência (App Ducally)

> **Objetivo:** implementar um fluxo completo para **gerar, salvar, carregar e comparar** planos de cortes. Este arquivo serve de roteiro para o Codex aplicar mudanças incrementais no código C++ atual.

---

## 1) Contexto atual (baseline)
- O app já:
  - Lê/salva **materiais** em `data/materiais.json` e importa/exporta **CSV**.
  - Calcula **cortes** com base no **preço por m²** do material escolhido e mostra um **resumo** no terminal.
- O que **não** faz ainda (alvo deste update):
  - **Persistir** os cortes feitos em um **arquivo externo** por execução.
  - **Reabrir** um plano de cortes gerado anteriormente.
  - **Comparar** planos de cortes (histórico/benchmark).

---

## 2) Estrutura de pastas (nova)
```
/data                # já existente (materiais, settings)
/out/planos/         # novo: cada execução gera uma pasta datada
/out/retalhos/       # novo: catálogo de sobras (futuro)
/logs/               # logs rotacionados por data (já/novo)
```

Cada plano de cortes deve ser salvo em `out/planos/YYYY-MM-DD_HHMMSS_<projeto>/` com:
```
plano.json   # fonte da verdade
plano.csv    # peças posicionadas/resumo por linha
plano.md     # comparação e métricas legíveis (opcional)
```

---

## 3) DTOs e Schemas sugeridos
### 3.1 `CorteDTO` (persistência)
```cpp
struct CorteDTO {
  std::string nome;   // etiqueta do corte
  double largura_m;   // em metros
  double comprimento_m; // em metros
  double porm2;       // preço aplicado nesta execução
  double area_m2;     // derivado
  double valor;       // derivado (area_m2 * porm2)
  bool rot90 = false; // reservado p/ futuro (layout)
};
```

### 3.2 `PlanoCorteDTO`
```cpp
struct PlanoCorteDTO {
  std::string id;           // ex: 2025-08-17_1830_Maca_80x200
  std::string projeto;      // opcional: nome do projeto
  std::string gerado_em;    // ISO-8601
  std::string algoritmo;    // ex: "simples" (placeholder p/ futuro)
  double porm2_usado;       // preço/m² efetivamente usado
  std::vector<CorteDTO> cortes;
  double total_area_m2;     // soma
  double total_valor;       // soma
  // futuros: aproveitamento, comprimento_corte, etc.
};
```

### 3.3 JSON do `plano.json` (exemplo mínimo)
```json
{
  "schema_version": 1,
  "id": "2025-08-17_1830_Maca_80x200",
  "projeto": "Maca_80x200",
  "gerado_em": "2025-08-17T18:30:12-03:00",
  "algoritmo": "simples",
  "porm2_usado": 180.0,
  "cortes": [
    {"nome":"Lateral","largura_m":2.0,"comprimento_m":0.15,"porm2":180.0,"area_m2":0.3,"valor":54.0}
  ],
  "total_area_m2": 0.3,
  "total_valor": 54.0
}
```

### 3.4 CSV do `plano.csv`
```
nome;largura_m;comprimento_m;area_m2;porm2;valor
Lateral;2,00;0,15;0,30;180,00;54,00
```

### 3.5 Índice global (histórico)
Arquivo `out/planos/index.json` para facilitar comparações:
```json
{ "planos": [
  {"id":"2025-08-17_1830_Maca_80x200","total_valor":54.0,"total_area_m2":0.3,"porm2":180.0}
]}
```

---

## 4) Persistência (novas funções sugeridas)
> Adicionar ao namespace `Persist` (reaproveitar `atomicWrite`):

```cpp
namespace Persist {
  bool savePlanoJSON(const std::string& dir, const PlanoCorteDTO& plano);
  bool savePlanoCSV (const std::string& dir, const PlanoCorteDTO& plano);
  bool loadPlanoJSON(const std::string& file, PlanoCorteDTO& out);
  bool updateIndex   (const PlanoCorteDTO& plano); // acrescenta/atualiza em out/planos/index.json
  std::string outPlanosDirFor(const std::string& projeto, const std::string& idTimestamp);
  std::string nowIso8601();
  std::string makeId(const std::string& projeto); // monta YYYY-MM-DD_HHMMSS_<projeto>
}
```

- `savePlanoJSON`: serializa `PlanoCorteDTO` (com `to_json/from_json`).
- `savePlanoCSV`: escreve cabeçalho e linhas (formato BR com vírgula).
- `updateIndex`: lê `out/planos/index.json` (se existir), adiciona entrada e salva.

---

## 5) Integração no fluxo atual
- **Alterar `App::solicitarCortes()`** para:
  1) Armazenar os cortes em `std::vector<Corte>` **e** construir `std::vector<CorteDTO>`.
  2) Ao finalizar, montar `PlanoCorteDTO` com somas de área/valor e `porm2_usado`.
  3) Gerar `id = Persist::makeId(projeto)` e `dir = Persist::outPlanosDirFor(projeto, id)`.
  4) Chamar `savePlanoJSON`, `savePlanoCSV` e `updateIndex`.
  5) Exibir o caminho da pasta gerada ao usuário.

- **Config extra (opcional)** em `settings.json`:
```json
{"decimal_places":2, "prefer":"ask", "output_dir":"out/planos"}
```

---

## 6) CLI (evolução)
- `--projeto <nome>`: nomeia a execução (default: "Projeto")
- Subcomandos futuros:
  - `cortes abrir --plano <path>`: imprime resumo do plano salvo.
  - `cortes listar [--limit 20]`: lista últimos planos do `index.json`.
  - `cortes comparar --ids <idA> <idB>`: gera relatório `.md` com deltas.

---

## 7) Critérios de aceite
- Ao concluir uma execução, existe uma **pasta** em `out/planos/<id>/` com **`plano.json` e `plano.csv`** válidos.
- `index.json` contém a execução recém-criada.
- Reabrir um plano via `loadPlanoJSON` reproduz os totais mostrados no terminal.

---

## 8) Testes (mínimo viável)
- **Unit**: `to_json/from_json` de `CorteDTO` e `PlanoCorteDTO`.
- **I/O**: `savePlanoJSON/CSV` + leitura do que foi salvo.
- **Index**: insere N entradas e confere integridade do arquivo.

---

## 9) Passos de implementação (ordem sugerida)
1. Criar DTOs e `to_json/from_json`.
2. Implementar helpers (`nowIso8601`, `makeId`, `outPlanosDirFor`).
3. Implementar `savePlanoJSON` e `savePlanoCSV`.
4. Implementar `updateIndex`.
5. Adaptar `App::solicitarCortes` para persistir o plano ao final.
6. (Opcional) Adicionar `--projeto` na CLI e subcomandos de histórico.

---

## 10) Notas de compatibilidade
- Unidades **mantidas em metros** (compatível com o código atual). Caso migre para milímetros no futuro, centralizar conversões em helpers.
- Reaproveitar `Persist::atomicWrite` para evitar corrupção em caso de falha.

> Após estes passos, teremos cortes **reprodutíveis, auditáveis e comparáveis**, prontos para evoluir para layout/otimização 2D em releases seguintes.

